# 权限管理RBAC
RBAC又名Resource-Base Access Control即为基于资源的权限管理。

## 何为角色
角色代表一系列可执行的操作或者责任的集合。用户账号往往与角色相关联。在一个系统中，一个用户能够操作的内容取决于与之关联的各个角色。
基于角色的访问控制（Role-Based Access Control）

由于角色代表了执行的内容，所有在软件开发过程中，可以使用角色来控制软件功能和数据的访问。这种访问控制方法叫做基于角色的访问控制，简称RBAC。
现如今，有两种RBAC访问控制方式：隐式（模糊）的方式和显示（明确）的方法。
隐式的访问控制

现在的大多数应用并不能明确的知道一个角色到底关联了哪些可执行的操作。可能你心里明白，但是这些系统并没有明确定义一个角色到底包含了哪些可执行的行为。 拿“project Manager”来说，系统中并没有对“project Manager”能进行什么样的操作进行明确定义，它仅仅是一个字符串名词。开发人员通常将这些名词写在程序里以进行访问控制。例如在判断一个用户是否能查看项目报表时，程序员可能会编码如下：
```
// 隐式的基于角色的权限控制。
if (user.hasRole("Project Manager") ) {
//show the project report button
} else {
//don't show the button
}
```
上面的代码判断是否有“Project Manager”的角色来决定是否显示查看项目报表按钮。它并没有明确语句来定义“Project Manager”这一角色到底包含哪些可以执行的行为，它只是假设一个关联了项目管理员角色的用户可查看项目报表，而开发人员也是基于这一假设来写if/else语句的。
脆弱的权限策略

上述权限策略非常脆弱，一个极小的权限方面的需求变动都可能导致上述代码需要重新修改。 举个例子，假如某一天这个开发团队被告知：“我们需要一个‘Department Manager’角色，他们也可以查看项目报表。”
这种情况，开发人员需要找到上面的代码，并将其修改成为：
```
//修改过的隐式的基于角色的权限控制:
if (user.hasRole("Project Manager") || user.hasRole("Department Manager") ) {
//show the project report button
} else {
//don't show the button
}
```
随后，开发人员需要更新他的测试用例，重新编译系统，还可能需要重走软件质量监控（QA）流程，然后重新部署上线。这一切仅仅是因为一个小小的权限方面的需求改变。 如果需求要求动态创建、删除角色以便他们自己配置角色，又该如何应对呢？
像上述的情况，隐式的形式的基于角色的访问控制方式难以满足需求。理想的情况如果权限需求变动不需要修改任何代码。怎么才能做到这一点呢？
显示的访问控制

从上面的例子可以发现，当权限需求发生变动时，隐式的权限访问控制方式会给程序带来承重的负担。理想的情况是，即使是正在运行的系统，你也可以修改权限策略却不影响最终用户的使用。当你发现某些错误的或危险的安全策略时，你可以迅速的修改策略配置，同时你的系统还能正常使用，二不需要重构代码重新部署系统。
显示的控制访问即可完成上述要求。从根本上说，这些代码最终实在保护资源（项目报表），是要界定一个用户能对这些资源进行什么样的操作（查看/修改）。当我们将权限访问控制分解到这种最原始的层次，我们就可以用一种更细粒度（更富有弹性）的方式来表达权限控制策略。 可以修改上述代码块，以基于资源的语言来更有效地进行权限访问控制： 代码块3. 显式的权限控制:
```
if (user.isPermitted("projectReport:view:12345")) {
//show the project report button
} else {
//don't show the button
}
```
上述例子可以明确的看到我们控制的是什么，它明确的表示“如果当前用户允许查看编号为12345的项目报表，则显示报表按钮”。也就是说，我们可以明确地说明了一个用户账号可以对一个资源实例进行具体操作。
为什么说这种方式更好

上面最后的示例代码块与前面的代码的主要区别：最后的代码块是基于什么受保护的，而不是谁可能有能力做什么。看似简单的区别，但后者对系统开发及部署有着深刻的影响。

 + 更少的代码重构：基于系统的功能（系统的资源及对资源的操作）来进行权限控制，而相对来说，系统的功能需求一旦确定下来，一段时间对他的改动相对还是比较少的。只是当系统的功能需求改变时，才会涉及到权限代码的改变。例如上面提到的查看项目报表的功能，显示的权限控制方式不会像传统隐式的RBAC权限控制那样因不同的用户/角色要进行这个操作就需要重构代码，只需要这个功能存在，显示的方式的权限控制代码是不需要改变的。
 + 更直观：保护资源对象、控制对资源对象的操作（对象及对象的行为），这种权限控制方式更符合人们的思想习惯。正因为符合这种直观的思维方式，面向对象的编辑思想及REST通信模型变得非常成功。
 + 更有弹性：上面的示例代码中没有写死哪些用户、组或角色可对资源进行什么操作。这意味着他可以支持任何安全模型的设计。例如，可以将操作（权限）直接分配给用户，或者他们可以被分配到一个角色，然后再将角色与用户关联，或者将多个角色关联到组上，等等。你完全可以根据应用的特点定制权限模型。
 + 外部安全策略管理：由于源码只反映资源和行为，而不是用户、组和角色，这样资源/行为与用户、组、角色的关联可以通过外部的模块或专用工具或管理控制台来完成。这意味着在权限需求变化时，开发人员并不需要花费时间来修改代码，业务分析师甚至最终用户就可以通过相应的管理工具修改权限策略配置。
 + 可在运行环境中做修改：因为基于资源的权限控制代码并不依赖于行为的主体（如组、角色、用户），你并没有将行为的主题的字符名词写在代码中，所以你甚至可以在程序运行的时候通过修改主体对资源进行的操作这一种方式，通过配置的方式就可应对权限方面需求的变动，再也不需要像隐式的RBAC方式那样需要重构代码。